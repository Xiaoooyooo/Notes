# ES6（块级作用域、变量的解构赋值）

## let和const

+ 一个代码块{}，即为一个作用域

+ ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域

+ 变量提升，使用var定义的变量和使用function定义的函数会被提前到函数或顶级作用域开头申明

+ 定义一个不可更改的对象：`const obj = Object.freeze({})`，用下面的方法来彻底冻结一个函数

  ```js
  var constantize = (obj) => {
    Object.freeze(obj);
    Object.keys(obj).forEach( (key, i) => {
      if ( typeof obj[key] === 'object' ) {
        constantize( obj[key] );
      }
    });
  };
  ```

+ ES6有六种申明变量的方式，`var, function, let, const, import, class`

+ let、const和class申明的全局变量不属于顶层对象（window）

  ```js
  let a = 1
  console.log(a)	//1
  console.log(window.a)	//undefined
  ```

## 变量的解构赋值

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。

解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。

### 数组的解构

```js
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []

let [x = 1] = [undefined];
x // 1
let [x = 1] = [null];
x // null
```

+ 如果解构不成功，变量的值就等于`undefined`
+ 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。
+ 解构赋值允许指定默认值，ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，只有当一个数组成员严格等于`undefined`，默认值才会生效。
+ 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
+ 默认值可以引用解构赋值的其他变量，但该变量必须已经声明

### 对象的解构

```js
// 例一
let { log, sin, cos } = Math;

// 例二
const { log } = console;
log('hello') // hello
```

+ 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量

+ 解构也可以用于嵌套结构的对象

  ```js
  let obj = {
    p: [
      'Hello',
      { y: 'World' }
    ]
  };
  
  let { p: [x, { y }] } = obj;
  x // "Hello"
  y // "World"
  
  //注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样
  let obj = {
    p: [
      'Hello',
      { y: 'World' }
    ]
  };
  
  let { p, p: [x, { y }] } = obj;
  x // "Hello"
  y // "World"
  p // ["Hello", {y: "World"}]
  ```

+ 对象的解构也可以指定默认值，默认值生效的条件是，对象的属性值严格等于`undefined`。

+ 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构

  ```js
  let arr = [1, 2, 3];
  let {0 : first, [arr.length - 1] : last} = arr;
  first // 1
  last // 3
  ```

### 字符串的解构赋值

+ 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。

  ```js
  const [a, b, c, d, e] = 'hello';
  a // "h"
  b // "e"
  c // "l"
  d // "l"
  e // "o"
  ```

+ 类似数组的对象都有一个`length`属性，因此还可以对这个属性解构赋值。

  ```js
  let {length : len} = 'hello';
  len // 5
  ```

### 数值和布尔值的解构赋值

+ 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。

  ```js
  let {toString: s} = 123;
  s === Number.prototype.toString // true
  
  let {toString: s} = true;
  s === Boolean.prototype.toString // true
  ```

### 函数参数的解构赋值

```js
//情况一
function add([x, y]){
  return x + y;
}
add([1, 2]); // 3

[[1, 2], [3, 4]].map(([a, b]) => a + b);
// [ 3, 7 ]


//情况二
function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]

//情况三
move(); // [0, 0]function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
```

+ 圆括号问题

  ```js
  // 变量申明不能使用，以下全部报错
  let [(a)] = [1];
  let {x: (c)} = {};
  let ({x: c}) = {};
  let {(x: c)} = {};
  let {(x): c} = {};
  let { o: ({ p: p }) } = { o: { p: 2 } };
  
  //函数参数也属于变量申明，不能使用圆括号，以下全部报错
  function f([(z)]) { return z; }
  function f([z,(x)]) { return x; }
  
  //赋值语句的模式部分，以下全部报错
  ({ p: a }) = { p: 42 };
  ([a]) = [5];
  [({ p: a }), { x: c }] = [{}, {}];
  
  //可以使用圆括号的情况：赋值语句的非模式部分，可以使用圆括号
  [(b)] = [3]; // 正确
  ({ p: (d) } = {}); // 正确
  [(parseInt.prop)] = [3]; // 正确
  ```

+ 用途

  + 交换变量的值`[x, y] = [y, x]`

  + 从函数返回多个值

    ```js
    // 返回一个数组
    function example() {
      return [1, 2, 3];
    }
    let [a, b, c] = example();
    
    // 返回一个对象
    function example() {
      return {
        foo: 1,
        bar: 2
      };
    }
    let { foo, bar } = example();
    ```

  + 函数参数的定义

    ```js
    // 参数是一组有次序的值
    function f([x, y, z]) { ... }
    f([1, 2, 3]);
    
    // 参数是一组无次序的值
    function f({x, y, z}) { ... }
    f({z: 3, y: 2, x: 1});
    ```

  + 提取 JSON 数据

    ```js
    let jsonData = {
      id: 42,
      status: "OK",
      data: [867, 5309]
    };
    
    let { id, status, data: number } = jsonData;
    
    console.log(id, status, number);
    ```

  + 函数参数的默认值

    ```js
    jQuery.ajax = function (url, {
      async = true,
      beforeSend = function () {},
      cache = true,
      complete = function () {},
      crossDomain = false,
      global = true,
      // ... more config
    } = {}) {
      // ... do stuff
    };
    ```

  + 遍历 Map 结构

    ```js
    const map = new Map();
    map.set('first', 'hello');
    map.set('second', 'world');
    
    for (let [key, value] of map) {
      console.log(key + " is " + value);
    }
    // first is hello
    // second is world
    
    // 获取键名
    for (let [key] of map) {
      // ...
    }
    // 获取键值
    for (let [,value] of map) {
      // ...
    }
    ```

  + 输入模块的指定方法

    ```js
    const { SourceMapConsumer, SourceNode } = require("source-map");
    ```

    

  