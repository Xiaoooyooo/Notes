## 理解对象

### 属性类别

**数据属性**

+ [[value]]
+ [[enumerable]]
+ [[writable]]
+ [[configurable]]

**访问器属性**

+ [[configurable]]
+ [[enumerable]]
+ [[getter]]
+ [[setter]]

**属性设置**

`Object.defineProperty([obj],[propertyName],[descriptor])`

```js
let obj = {
    _name: 'Tom'
}
//定义数据属性
Object.defineProperty(obj, 'name', {
    writable: true,
    configurable: true,
    enumerable: true,
    value: 'Tom'
})
//定义访问器属性
Object.defineProperty(obj, 'name', {
    configurable: true,
    enumerable: true,
    set(val) {
        this._name = val
    },
    get(){
        return this._name
    }
})

//一次性定义多个属性
Object.defineProperties(obj, {
    name: {
        value: 'Mike',
        //...
    },
    _age: {
        value: 20,
        //...
    },
    age: {
        set(val){
            this._age = val
        },
        get(){
            return this._age
        }
    }
})
```

**属性特性读取**

`Object.getOwnPropertyDescriptor([obj], [property])`

**检测属性是否自有**

`[obj].hasOwnProperty([property])`

### 对象创建

#### 工厂模式

略

#### 构造函数模式

```js
let Person = function(name){
    this.name = name
    this.sayHi = function() {
        alert(`Hi! I'm ${this.name}`)
    }
}
let tom = new Person("Tom")
/**
 * 注意事项：
 **/
tom.constructor === Person //true
tom instanceof Person //true
```

#### 原型模式

```js
function Person(){}
Person.prototype.name = 'tom'
Person.prototype.age = 22
Person.prototype.sayHi = function(){
    alert(`Hi! I'm ${this.name}`)
}
let tom = new Person

/**
 * 注意事项：
 **/
tom.__proto__ === Person.prototype //true
Person.prototype.isPrototypeOf(tom) //true
Object.getPrototypeOf(tom) === Person.prototype //true
```

#### 动态原型模式

```js
function Person(name){
    this.name = name
    if(typeof this.sayName != 'function'){
        //这里的判断语句可以是原型初始化之后任何存在的属性和方法，只需要一次判断即可
        this.sayName = function() {
            alert(this.name)
        }
    }
}
```

#### 继承

```js
function Father(fname) {
    this.fname = fname
    this.colors = ['red', 'green', 'blue']
}
Father.prototype.greeting = function() {
    alert("Greetings from Father")
}
function Son(fname, sname) {
    Father.call(this, fname)
    this.sname = sname
}
//寄生组合式继承
let prototype = Object.create(Father.prototype)
prototype.constructor = Son
Son.prototype = prototype

Son.prototype.sayHi = function() {
    alert('Hi from Son')
}
let s = new Son('father', 'son')
```



### 对象方法

`Object.keys(obj):`列出所给对象实例自身的所有可枚举属性

`Object.getOwnPropertyNames(obj):`列出所给对像实例自身的所有属性（包含不可枚举属性）

> for...in...循环遍历对象时会包含实例原型的属性

`Object.create(obj, anotherobj):`浅复制一个对象

```js
let obj = {
    one: 'one'
}
let obj1 = Object.create(obj, {
    two: {
        value: 'two'
    }
})
```



#### 对象的实例的方法

`obj.hasOwnProperty(property):`检测属性为实例所有还是原型所有

