---
title: 队列
date: 2021-03-14 13:00:23
tags:
	- 数据结构
	- 队列
categories:
	- 数据结构
---

# 队列

类似于栈，不同的是，栈遵循的是后进先出，而队列则是先进先出

+ **先进：**队列的数据新增只能在队列的末端进行
+ **先出：**队列的数据删除只能在队列的头部进行

实现方式有**顺序队列**——依赖数组实现，**链式队列**——依赖链表实现

链式队列分为**循环队列**和**链式队列**，二者的优缺点如下

+ 时间复杂度上：
  + 二者新增、删除的操作都为O(1)
  + 在查找操作中，队列只有通过全局遍历的方式进行，时间复杂度为O(n)
+ 空间复杂度上：
  + 循环队列必须有一个固定的长度，因此存在储存元素数量和空间浪费的问题
  + 链式队列更为灵活一些

在实践中，如果能够确定队列的长度时，建议使用循环队列，反之使用链式队列

```js
//链式队列示例
class ListNode{
    constructor(value){
        this.value = value;
        this.next = null
    }
}
class Queue{
    constructor(){
        this.front = new ListNode(-1)
        this.rear = this.front
        this.isEmpty = true
    }
    enterQueue(value){
        this.rear.next = new ListNode(value)
        this.rear = this.rear.next
        this.isEmpty === true && (this.isEmpty = false)
    }
    outQueue(){
        if(this.isEmpty === true) return '列表为空'
        let delNode = this.front.next
        this.front.next = delNode.next
        if(this.front.next === null){
            this.rear = this.front
            this.isEmpty = true
        }
        return delNode
    }
}
```

## 应用案例

约瑟夫环是一个数学的应用问题，具体为，已知 n 个人（以编号 1，2，3...n 分别表示）围坐在一张圆桌周围。从编号为 k 的人开始报数，数到 m 的那个人出列；他的下一个人又从 1 开始报数，数到 m 的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。这个问题的输入变量就是 n 和 m，即 n 个人和数到 m 的出列的人。输出的结果，就是 n 个人出列的顺序。

```js
// 10个人，数到3的出列
class LoopQueue {
  queue: undefined[] | number[];
  front: number;
  rear: number;
  isEmpty: boolean;
  constructor(length: number) {
    this.queue = Array(length).fill(undefined)
    this.front = 0
    this.rear = 0
    this.isEmpty = true
  }
  enterQueue(value: number): number | string {
    if (!this.isEmpty && this.front === this.rear) return '队列已满'
    this.queue[this.rear] = value
    this.rear++
    this.rear === this.queue.length && (this.rear = 0)
    this.isEmpty && (this.isEmpty = false)
  }
  outQueue(): number {
    if (this.isEmpty && this.front === this.rear) return undefined
    let d: number = this.queue[this.front]
    this.queue[this.front] = undefined
    this.front++
    this.front === this.queue.length && (this.front = 0)
    this.front === this.rear && (this.isEmpty = true)
    return d
  }
}
let loopQ: LoopQueue = new LoopQueue(10)
console.log(loopQ)
for (let i = 0; i < 10; i++) {
  loopQ.enterQueue(i)
}
let t:number = 1
while(!loopQ.isEmpty){
  let d = loopQ.outQueue()
  if(t++ % 3 === 0){
    console.log(d)
  }else{
    loopQ.enterQueue(d)
  }
}
// 2 5 8 1 6 0 7 4 9 3
```



